/*
 * MIPI-DSI based ea8061 AMOLED LCD 5.5 inch panel driver.
 *
 * Copyright (c) 2017 Simon Shields, <simon@lineageos.org>
 *
 * Based on the s6e8aa0 panel driver,
 * Copyright (c) 2013 Samsung Electronics Co., Ltd
 *
 * Inki Dae, <inki.dae@samsung.com>
 * Donghwa Lee, <dh09.lee@samsung.com>
 * Joongmock Shin <jmock.shin@samsung.com>
 * Eunchul Kim <chulspro.kim@samsung.com>
 * Tomasz Figa <t.figa@samsung.com>
 * Andrzej Hajda <a.hajda@samsung.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
*/

#include <drm/drmP.h>
#include <drm/drm_mipi_dsi.h>
#include <drm/drm_panel.h>

#include <linux/gpio/consumer.h>
#include <linux/regulator/consumer.h>

#include <linux/backlight.h>
#include <video/mipi_display.h>
#include <video/of_videomode.h>
#include <video/videomode.h>

#define M4_VERSION 0x13

#define AID_TABLE_LEN			2
#define GAMMA_LEVEL_NUM			33
#define GAMMA_TABLE_LEN			33

typedef u8 ea8061_gamma_table[GAMMA_TABLE_LEN];
typedef u8 ea8061_aid_table[AID_TABLE_LEN];

#define EA8061_STATE_BIT_ENABLED	0

struct ea8061 {
	struct device *dev;
	struct drm_panel panel;

	struct regulator_bulk_data supplies[2];
	struct gpio_desc *reset_gpio;
	u32 power_on_delay;
	u32 reset_delay;
	u32 init_delay;
	struct videomode vm;
	u32 width_mm;
	u32 height_mm;

	unsigned long state;
	u8 version;
	u8 id;
	int brightness;

	/* This field is tested by functions directly accessing DSI bus before
	 * transfer, transfer is skipped if it is set. In case of transfer
	 * failure or unexpected response the field is set to error value.
	 * Such construct allows to eliminate many checks in higher level
	 * functions.
	 */
	int error;
};


static const u8 ea8061_elvss_param[GAMMA_LEVEL_NUM] = {
	0x20, 0x20, 0x20, 0x1f, 0x1f, 0x1f, 0x1e, 0x1e, /* 20-90cd */
	0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1b, 0x19, 0x17, /* 100-130cd */
	0x16, 0x14, 0x12, 0x10, 0x0f, 0x0f, 0x0f, 0x0f, /* 140-186cd */
	0x0f, 0x15, 0x14, 0x13, 0x12, 0x11, 0x10, 0x10, /* 188-250cd */
	0x0b, /* 300cd */
};

static const ea8061_aid_table ea8061_aid_tables[GAMMA_LEVEL_NUM] = {
	{0x04, 0x45}, {0x03, 0xdf}, {0x03, 0x74}, {0x03, 0x0a}, /* 20-50cd */
	{0x02, 0x95}, {0x02, 0x25}, {0x01, 0xab}, {0x01, 0x36}, /* 60-90cd */
	{0x00, 0xbc}, {0x00, 0xfe}, {0x01, 0x40}, {0x01, 0x82}, /* 100-106cd */
	{0x01, 0xc4}, {0x02, 0x06}, {0x02, 0x06}, {0x02, 0x06}, /* 108-130cd */
	{0x02, 0x06}, {0x02, 0x06}, {0x02, 0x06}, {0x02, 0x06}, /* 140-170cd */
	{0x02, 0x06}, {0x01, 0x9f}, {0x01, 0x37}, {0x00, 0xcf}, /* 180-186cd */
	{0x00, 0x68}, {0x00, 0x0a}, {0x00, 0x0a}, {0x00, 0x0a}, /* 188-210cd */
	{0x00, 0x0a}, {0x00, 0x0a}, {0x00, 0x0a}, {0x00, 0x0a}, /* 220-250cd */
	{0x00, 0x0a}, /* 300cd */
};

static const ea8061_gamma_table ea8061_gamma_tables[GAMMA_LEVEL_NUM] = {
	{
		/* 20cd */
		0xca, 0x00, 0xd9, 0x00, 0xd5, 0x00, 0xd3, 0x87, 0x88, 0x87,
		0x88, 0x87, 0x88, 0x86, 0x89, 0x88, 0x87, 0x88, 0x89, 0x74,
		0x65, 0x81, 0x68, 0x66, 0x83, 0x68, 0x6f, 0xa9, 0x37, 0x42,
		0x2e, 0x31, 0x02,
	}, {
		/* 30cd */
		0xca, 0x00, 0xd9, 0x00, 0xd5, 0x00, 0xd3, 0x87, 0x88, 0x87,
		0x87, 0x87, 0x87, 0x85, 0x88, 0x87, 0x87, 0x87, 0x88, 0x7e,
		0x77, 0x83, 0x6d, 0x66, 0x7c, 0x68, 0x6f, 0xa1, 0x37, 0x42,
		0x2e, 0x31, 0x02,
	}, {
		/* 40cd */
		0xca, 0x00, 0xd9, 0x00, 0xd5, 0x00, 0xd3, 0x86, 0x87, 0x87,
		0x88, 0x87, 0x88, 0x84, 0x87, 0x86, 0x88, 0x89, 0x89, 0x7f,
		0x83, 0x81, 0x70, 0x63, 0x79, 0x65, 0x67, 0x98, 0x3b, 0x48,
		0x31, 0x31, 0x02,
	}, {
		/* 50cd */
		0xca, 0x00, 0xd9, 0x00, 0xd5, 0x00, 0xd3, 0x86, 0x87, 0x87,
		0x87, 0x87, 0x87, 0x85, 0x88, 0x87, 0x86, 0x87, 0x87, 0x81,
		0x85, 0x83, 0x75, 0x6a, 0x79, 0x6b, 0x67, 0x93, 0x3b, 0x48,
		0x31, 0x31, 0x02,
	}, {
		/* 60cd */
		0xca, 0x00, 0xd9, 0x00, 0xd5, 0x00, 0xd3, 0x86, 0x87, 0x87,
		0x87, 0x87, 0x87, 0x84, 0x87, 0x86, 0x85, 0x86, 0x87, 0x80,
		0x83, 0x82, 0x7b, 0x6e, 0x7c, 0x6d, 0x67, 0x8e, 0x3b, 0x48,
		0x31, 0x31, 0x02,
	}, {
		/* 70cd */
		0xca, 0x00, 0xd9, 0x00, 0xd5, 0x00, 0xd3, 0x86, 0x86, 0x86,
		0x87, 0x87, 0x87, 0x85, 0x88, 0x87, 0x85, 0x86, 0x87, 0x80,
		0x83, 0x82, 0x79, 0x6d, 0x78, 0x73, 0x6b, 0x8f, 0x3b, 0x48,
		0x31, 0x31, 0x02,
	}, {
		/* 80cd */
		0xca, 0x00, 0xd9, 0x00, 0xd5, 0x00, 0xd3, 0x86, 0x86, 0x86,
		0x87, 0x87, 0x87, 0x84, 0x86, 0x85, 0x86, 0x87, 0x88, 0x80,
		0x83, 0x82, 0x7b, 0x6f, 0x78, 0x74, 0x6b, 0x8c, 0x3b, 0x48,
		0x31, 0x31, 0x02,
	}, {
		/* 90cd */
		0xca, 0x00, 0xd9, 0x00, 0xd5, 0x00, 0xd3, 0x86, 0x86, 0x86,
		0x87, 0x87, 0x87, 0x84, 0x86, 0x85, 0x84, 0x85, 0x86, 0x7e,
		0x81, 0x80, 0x7f, 0x74, 0x7c, 0x75, 0x6b, 0x8a, 0x3b, 0x48,
		0x31, 0x31, 0x02,
	}, {
		/* 100cd */
		0xca, 0x00, 0xd9, 0x00, 0xd5, 0x00, 0xd3, 0x86, 0x86, 0x86,
		0x87, 0x86, 0x86, 0x85, 0x87, 0x86, 0x84, 0x85, 0x86, 0x7e,
		0x81, 0x80, 0x7f, 0x77, 0x7c, 0x70, 0x5f, 0x83, 0x40, 0x4f,
		0x35, 0x31, 0x02,
	}, {
		/* 102cd */
		0xca, 0x00, 0xdb, 0x00, 0xd7, 0x00, 0xd6, 0x85, 0x86, 0x86, 
		0x87, 0x86, 0x86, 0x83, 0x85, 0x85, 0x86, 0x87, 0x87, 0x7e,
		0x81, 0x80, 0x7f, 0x77, 0x7c, 0x7b, 0x73, 0x8a, 0x37, 0x42,
		0x2e, 0x31, 0x02,
	}, {
		/* 104cd */
		0xca, 0x00, 0xde, 0x00, 0xda, 0x00, 0xd9, 0x85, 0x86, 0x85,
		0x87, 0x86, 0x86, 0x84, 0x85, 0x85, 0x85, 0x85, 0x86, 0x7f,
		0x83, 0x81, 0x7c, 0x73, 0x79, 0x7b, 0x72, 0x8a, 0x37, 0x42,
		0x2e, 0x31, 0x02,
	}, {
		/* 106cd */
		0xca, 0x00, 0xe1, 0x00, 0xdd, 0x00, 0xdc, 0x84, 0x85, 0x84,
		0x86, 0x85, 0x85, 0x83, 0x84, 0x84, 0x84, 0x84, 0x85, 0x7f,
		0x83, 0x81, 0x7e, 0x76, 0x7a, 0x80, 0x7a, 0x8b, 0x33, 0x3c,
		0x2b, 0x31, 0x02,
	}, {
		/* 108cd */
		0xca, 0x00, 0xe4, 0x00, 0xe1, 0x00, 0xe0, 0x84, 0x86, 0x85,
		0x84, 0x83, 0x84, 0x83, 0x85, 0x84, 0x84, 0x84, 0x84, 0x81,
		0x84, 0x83, 0x7d, 0x77, 0x7a, 0x7d, 0x74, 0x87, 0x33, 0x3c,
		0x2b, 0x31, 0x02,
	}, {
		/* 110cd */
		0xca, 0x00, 0xe7, 0x00, 0xe4, 0x00, 0xe3, 0x84, 0x84, 0x84,
		0x84, 0x83, 0x84, 0x83, 0x84, 0x84, 0x83, 0x83, 0x84, 0x80,
		0x83, 0x82, 0x7f, 0x79, 0x7d, 0x7a, 0x70, 0x84, 0x33, 0x3c,
		0x2b, 0x31, 0x02,
	}, {
		/* 120cd */
		0xca, 0x00, 0xeb, 0x00, 0xe8, 0x00, 0xe7, 0x83, 0x84, 0x84,
		0x83, 0x82, 0x83, 0x83, 0x84, 0x83, 0x83, 0x83, 0x83, 0x7f,
		0x82, 0x81, 0x7d, 0x77, 0x7a, 0x80, 0x7c, 0x89, 0x2e, 0x37,
		0x28, 0x31, 0x02,
	}, {
		/* 130cd */
		0xca, 0x00, 0xee, 0x00, 0xec, 0x00, 0xec, 0x83, 0x83, 0x83,
		0x82, 0x82, 0x82, 0x81, 0x82, 0x82, 0x84, 0x84, 0x84, 0x7f,
		0x80, 0x7f, 0x7e, 0x7a, 0x7c, 0x7d, 0x78, 0x86, 0x2e, 0x37,
		0x28, 0x31, 0x02,
	}, {
		/* 140cd */
		0xca, 0x00, 0xf1, 0x00, 0xef, 0x00, 0xef, 0x82, 0x82, 0x82,
		0x82, 0x82, 0x82, 0x81, 0x82, 0x82, 0x82, 0x82, 0x82, 0x7f,
		0x81, 0x80, 0x7f, 0x7c, 0x7e, 0x7b, 0x74, 0x82, 0x2e, 0x37,
		0x28, 0x31, 0x02,
	}, {
		/* 150cd */
		0xca, 0x00, 0xf4, 0x00, 0xf2, 0x00, 0xf2, 0x81, 0x82, 0x82,
		0x82, 0x82, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x80,
		0x81, 0x80, 0x7d, 0x7b, 0x7c, 0x81, 0x7f, 0x88, 0x85,
		0x87,0x84, 0x31, 0x02,
	}, {
		/* 160cd */
		0xca, 0x00, 0xf7, 0x00, 0xf6, 0x00, 0xf5, 0x80, 0x81, 0x81,
		0x82, 0x81, 0x81, 0x80, 0x81, 0x80, 0x82, 0x82, 0x82, 0x7f,
		0x80, 0x7f, 0x7f, 0x7d, 0x7e, 0x7e, 0x7b, 0x84, 0x85, 0x87,
		0x84, 0x31, 0x02,
	}, {
		/* 170cd */
		0xca, 0x00, 0xf9, 0x00, 0xf9, 0x00, 0xf8, 0x80, 0x81, 0x80,
		0x81, 0x80, 0x80, 0x81, 0x82, 0x81, 0x80, 0x80, 0x81, 0x80,
		0x80, 0x80, 0x80, 0x7f, 0x80, 0x7b, 0x77, 0x81, 0x85, 0x87,
		0x84, 0x31, 0x02,
	}, {
		/* 180cd */
		0xca, 0x00, 0xfc, 0x00, 0xfb, 0x00, 0xfb, 0x80, 0x80, 0x80,
		0x80, 0x80, 0x80, 0x7f, 0x80, 0x80, 0x81, 0x81, 0x81, 0x80,
		0x81, 0x81, 0x7e, 0x7d, 0x7e, 0x81, 0x81, 0x86, 0x7f, 0x80,
		0x7f, 0x31, 0x02,
	}, {
		/* 182cd */
		0xca, 0x00, 0xf8, 0x00, 0xf7, 0x00, 0xf6, 0x81, 0x81, 0x81,
		0x81, 0x81, 0x81, 0x80, 0x81, 0x81, 0x81, 0x81, 0x81, 0x7f,
		0x80, 0x7f, 0x7f, 0x7d, 0x7e, 0x7f, 0x7c, 0x83, 0x85, 0x87,
		0x84, 0x31, 0x02,
	}, {
		/* 184cd */
		0xca, 0x00, 0xf4, 0x00, 0xf2, 0x00, 0xf2, 0x81, 0x82, 0x82,
		0x81, 0x81, 0x81, 0x80, 0x81, 0x81, 0x82, 0x83, 0x83, 0x7e,
		0x7f, 0x7f, 0x7f, 0x7c, 0x7e, 0x7c, 0x76, 0x80, 0x2e, 0x37,
		0x28, 0x31, 0x02,
	}, {
		/* 186cd */
		0xca, 0x00, 0xf1, 0x00, 0xef, 0x00, 0xee, 0x82, 0x82, 0x82,
		0x82, 0x82, 0x82, 0x81, 0x82, 0x82, 0x82, 0x82, 0x82, 0x7f,
		0x80, 0x7f, 0x7e, 0x7a, 0x7c, 0x7e, 0x7a, 0x83, 0x2e, 0x37,
		0x28, 0x31, 0x02,
	}, {
		/* 188cd */
		0xca, 0x00, 0xee, 0x00, 0xec, 0x00, 0xec, 0x82, 0x83, 0x82,
		0x82, 0x82, 0x82, 0x81, 0x82, 0x81, 0x82, 0x82, 0x82, 0x7f,
		0x82, 0x81, 0x7d, 0x77, 0x7a, 0x81, 0x7e, 0x86, 0x2e, 0x37,
		0x28, 0x31, 0x02,
	}, {
		/* 190cd */
		0xca, 0x00, 0xeb, 0x00, 0xe8, 0x00, 0xe8, 0x82, 0x83, 0x83,
		0x83, 0x82, 0x83, 0x82, 0x83, 0x83, 0x83, 0x83, 0x83, 0x7f,
		0x82, 0x80, 0x7f, 0x79, 0x7d, 0x7b, 0x72, 0x81, 0x33, 0x3c,
		0x2b, 0x31, 0x02,
	}, {
		/* 200cd */
		0xca, 0x00, 0xee, 0x00, 0xec, 0x00, 0xeb, 0x82, 0x83, 0x82,
		0x82, 0x82, 0x82, 0x80, 0x81, 0x81, 0x83, 0x83, 0x83, 0x7f,
		0x82, 0x81, 0x7d, 0x77, 0x7a, 0x7b, 0x72, 0x81, 0x33, 0x3c,
		0x2b, 0x31, 0x02,
	}, {
		/* 210cd */
		0xca, 0x00, 0xf0, 0x00, 0xee, 0x00, 0xed, 0x82, 0x82, 0x82,
		0x82, 0x81, 0x81, 0x80, 0x81, 0x81, 0x82, 0x83, 0x83, 0x7e,
		0x80, 0x7f, 0x80, 0x7c, 0x7e, 0x7e, 0x7a, 0x83, 0x2e, 0x37,
		0x28, 0x31, 0x02,
	}, {
		/* 220cd */
		0xca, 0x00, 0xf2, 0x00, 0xf0, 0x00, 0xf0, 0x80, 0x81, 0x81,
		0x82, 0x82, 0x82, 0x80, 0x81, 0x81, 0x82, 0x82, 0x82, 0x7f,
		0x80, 0x7f, 0x7e, 0x7a, 0x7c, 0x7e, 0x7a, 0x83, 0x2e, 0x37,
		0x28, 0x31, 0x02,
	}, {
		/* 230cd */
		0xca, 0x00, 0xf4, 0x00, 0xf2, 0x00, 0xf2, 0x81, 0x81, 0x81,
		0x81, 0x81, 0x80, 0x80, 0x81, 0x80, 0x82, 0x82, 0x82, 0x7f,
		0x81, 0x80, 0x7c, 0x78, 0x7a, 0x7e, 0x7a, 0x83, 0x2e, 0x37,
		0x28, 0x31, 0x02,
	}, {
		/* 240cd */
		0xca, 0x00, 0xf6, 0x00, 0xf4, 0x00, 0xf4, 0x80, 0x81, 0x81,
		0x81, 0x81, 0x81, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x7f,
		0x81, 0x80, 0x7f, 0x7c, 0x7e, 0x7c, 0x76, 0x7f, 0x2e, 0x37,
		0x28, 0x31, 0x02,
	}, {
		/* 250cd */
		0xca, 0x00, 0xf8, 0x00, 0xf7, 0x00, 0xf6, 0x80, 0x80, 0x80,
		0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x81, 0x80,
		0x81, 0x80, 0x7d, 0x7b, 0x7c, 0x7c, 0x76, 0x7f, 0x2e, 0x37,
		0x28, 0x31, 0x02,
	}, {
		/* 300cd */
		0xca, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x7f, 0x7f, 0x7f,
		0x80, 0x80, 0x80, 0x7f, 0x7f, 0x80, 0x7f, 0x7f, 0x7f, 0x80,
		0x80, 0x7f, 0x7f, 0x80, 0x7f, 0x80, 0x80, 0x80, 0x7f, 0x80,
		0x7f, 0x31, 0x02,
	},
};

static inline struct ea8061 *panel_to_ea8061(struct drm_panel *panel)
{
	return container_of(panel, struct ea8061, panel);
}

static int ea8061_clear_error(struct ea8061 *ctx)
{
	int ret = ctx->error;

	ctx->error = 0;
	return ret;
}

static void ea8061_dcs_write(struct ea8061 *ctx, const void *data, size_t len)
{
	struct mipi_dsi_device *dsi = to_mipi_dsi_device(ctx->dev);
	ssize_t ret;

	if (ctx->error < 0)
		return;

	ret = mipi_dsi_dcs_write_buffer(dsi, data, len);
	if (ret < 0) {
		dev_err(ctx->dev, "error %zd writing dcs seq: %*ph\n", ret,
			(int)len, data);
		ctx->error = ret;
	}
}

static int ea8061_dcs_read(struct ea8061 *ctx, u8 cmd, void *data, size_t len)
{
	struct mipi_dsi_device *dsi = to_mipi_dsi_device(ctx->dev);
	int ret;

	if (ctx->error < 0)
		return ctx->error;

	ret = mipi_dsi_dcs_read(dsi, cmd, data, len);
	if (ret < 0) {
		dev_err(ctx->dev, "error %d reading dcs seq(%#x)\n", ret, cmd);
		ctx->error = ret;
	}

	return ret;
}

#define ea8061_dcs_write_seq_static(ctx, seq...) \
({\
	static const u8 d[] = { seq };\
	ea8061_dcs_write(ctx, d, ARRAY_SIZE(d));\
})

static void ea8061_apply_level_2_key(struct ea8061 *ctx)
{
	ea8061_dcs_write_seq_static(ctx, 0xf0, 0x5a, 0x5a);
}

static void ea8061_panel_cond_set(struct ea8061 *ctx)
{
	if (ctx->version == M4_VERSION)
		ea8061_dcs_write_seq_static(ctx,
				0xc4, 0x4e, 0xbd, 0x00, 0x00, 0x58, 0xa7, 
				0x0b, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 
				0x0b, 0x92, 0x0b, 0x92, 0x08, 0x08, 0x07,
				0x30, 0x50, 0x30, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x02, 0x04, 0x04);
	else
		ea8061_dcs_write_seq_static(ctx,
				0xC4, 0x4E, 0xBD, 0x00, 0x00, 0x58, 0xA7,
				0x0B, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x0B, 0x92, 0x0B, 0x92, 0x08, 0x08, 0x07,
				0x30, 0x30, 0x30, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x02, 0x04, 0x04);
}

static void ea8061_display_condition_set(struct ea8061 *ctx)
{
	ea8061_dcs_write_seq_static(ctx, 0x36, 0x02, 0x00);
}

static void ea8061_etc_power_control(struct ea8061 *ctx)
{
	ea8061_dcs_write_seq_static(ctx, 0x55, 0x00, 0x00);
}

static void ea8061_etc_elvss_control(struct ea8061 *ctx)
{
	ea8061_dcs_write_seq_static(ctx, 0xb2, 0x0e, 0xb4, 0xa0, 0x00,
			0x00, 0x00, 0x00);
}

static void ea8061_apply_level_3_key(struct ea8061 *ctx)
{
	ea8061_dcs_write_seq_static(ctx, 0xfc, 0x5a, 0x5a);
}

static void ea8061_aid_set(struct ea8061 *ctx)
{
	u8 aid_cmd[AID_TABLE_LEN + 1] = {
		0xb3, 0x00, 0x00,
	};
	if (ctx->error)
		return;

	aid_cmd[1] = ea8061_aid_tables[ctx->brightness][0];
	aid_cmd[2] = ea8061_aid_tables[ctx->brightness][1];

	ea8061_dcs_write(ctx, aid_cmd, ARRAY_SIZE(aid_cmd));
}

static void ea8061_acl_set(struct ea8061 *ctx)
{
	u8 acl_seq[] = {0x55, 0x02, 0x00};
	if (ctx->error)
		return;

	switch (ctx->brightness) {
	case 0: /* <30cd */
		acl_seq[1] = 0x00;
		break;
	case 1: /* 30cd */
		acl_seq[1] = 0x01;
		break;
	}

	ea8061_dcs_write(ctx, acl_seq, ARRAY_SIZE(acl_seq));
}

static void ea8061_elvss_set(struct ea8061 *ctx)
{
	u8 elvss_cmd[] = {
		0xb2, 0x00, 0xb4, 0xa0, 0x00, 0x00, 0x00, 0x00,
	};

	if (ctx->error)
		return;

	elvss_cmd[1] = ea8061_elvss_param[ctx->brightness];
	ea8061_dcs_write(ctx, elvss_cmd, ARRAY_SIZE(elvss_cmd));
}

static void ea8061_brightness_set(struct ea8061 *ctx)
{
	const u8 *gamma;

	if (ctx->error)
		return;

	gamma = ea8061_gamma_tables[ctx->brightness];

	/* prepare for gamma table update */
	ea8061_dcs_write_seq_static(ctx, 0xf7, 0x5a, 0x5a);

	ea8061_dcs_write(ctx, gamma, GAMMA_TABLE_LEN);

	/* apply gamma table update. */
	ea8061_dcs_write_seq_static(ctx, 0xf7, 0xa5, 0xa5);

	ea8061_aid_set(ctx);
	ea8061_acl_set(ctx);
	ea8061_elvss_set(ctx);
}

static void ea8061_magna_gp(struct ea8061 *ctx)
{
	ea8061_dcs_write_seq_static(ctx, 0xb0, 0x0e);
}

static void ea8061_magna_refresh_disable(struct ea8061 *ctx)
{
	ea8061_dcs_write_seq_static(ctx, 0xdd, 0x00, 0x00);
}

static void ea8061_ltps_aid(struct ea8061 *ctx)
{
	ea8061_dcs_write_seq_static(ctx, 0xb3, 0x0, 0x0a);
}

static void ea8061_slew(struct ea8061 *ctx)
{
	if (ctx->version == M4_VERSION)
		ea8061_dcs_write_seq_static(ctx, 0xb4, 0x33, 0x0d, 0x00);
	else {
		if (ctx->id == 0x00 || ctx->id == 0x01)
			ea8061_dcs_write_seq_static(ctx, 0xb4, 0x33, 0x0e, 0x00);
		else if (ctx->id == 0x02)
			ea8061_dcs_write_seq_static(ctx, 0xb4, 0x33, 0x09, 0x00);
		else if (ctx->id == 0x03)
			ea8061_dcs_write_seq_static(ctx, 0xb4, 0x33, 0x0d, 0x00);
		else
			ea8061_dcs_write_seq_static(ctx, 0xb4, 0x33, 0x0a, 0x00);
	}
}

static void ea8061_panel_init(struct ea8061 *ctx)
{
	ea8061_apply_level_2_key(ctx);
	ea8061_apply_level_3_key(ctx);
	msleep(20);

	ea8061_magna_gp(ctx);
	ea8061_magna_refresh_disable(ctx);

	ea8061_panel_cond_set(ctx);
	ea8061_display_condition_set(ctx);
	ea8061_brightness_set(ctx);
	ea8061_ltps_aid(ctx);
	ea8061_etc_elvss_control(ctx);
	ea8061_etc_power_control(ctx);
	ea8061_slew(ctx);
	msleep(ctx->init_delay);
	
	ea8061_dcs_write_seq_static(ctx, MIPI_DCS_EXIT_SLEEP_MODE);
	msleep(40);

	ea8061_dcs_write_seq_static(ctx, 0x29, 0x00, 0x00);
}

static void ea8061_set_maximum_return_packet_size(struct ea8061 *ctx,
						   u16 size)
{
	struct mipi_dsi_device *dsi = to_mipi_dsi_device(ctx->dev);
	int ret;

	if (ctx->error < 0)
		return;

	ret = mipi_dsi_set_maximum_return_packet_size(dsi, size);
	if (ret < 0) {
		dev_err(ctx->dev,
			"error %d setting maximum return packet size to %d\n",
			ret, size);
		ctx->error = ret;
	}
}

static void ea8061_read_mtp_id(struct ea8061 *ctx)
{
	u8 id[3];
	int ret;

	ea8061_dcs_write_seq_static(ctx, 0xfd, 0xd1);

	ret = ea8061_dcs_read(ctx, 0xfe, id, ARRAY_SIZE(id));
	if (ret < ARRAY_SIZE(id) || id[0] == 0x00) {
		dev_err(ctx->dev, "read id failed\n");
		ctx->error = -EIO;
		return;
	}

	dev_info(ctx->dev, "ID: 0x%2x, 0x%2x, 0x%2x\n", id[0], id[1], id[2]);

	ctx->version = id[1];
	ctx->id = id[2];
}

static void ea8061_set_sequence(struct ea8061 *ctx)
{
	ea8061_set_maximum_return_packet_size(ctx, 3);
	ea8061_read_mtp_id(ctx);
	ea8061_panel_init(ctx);
	ea8061_dcs_write_seq_static(ctx, MIPI_DCS_SET_DISPLAY_ON);
}

static int ea8061_power_on(struct ea8061 *ctx)
{
	int ret;

	ret = regulator_bulk_enable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
	if (ret < 0)
		return ret;

	msleep(ctx->power_on_delay);

	gpiod_set_value(ctx->reset_gpio, 0);
	usleep_range(10000, 11000);
	gpiod_set_value(ctx->reset_gpio, 1);

	msleep(ctx->reset_delay);

	return 0;
}

static int ea8061_power_off(struct ea8061 *ctx)
{
	return regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
}

static int ea8061_disable(struct drm_panel *panel)
{
	return 0;
}

static int ea8061_unprepare(struct drm_panel *panel)
{
	struct ea8061 *ctx = panel_to_ea8061(panel);

	clear_bit(EA8061_STATE_BIT_ENABLED, &ctx->state);
	ea8061_dcs_write_seq_static(ctx, MIPI_DCS_SET_DISPLAY_OFF);
	ea8061_dcs_write_seq_static(ctx, MIPI_DCS_ENTER_SLEEP_MODE);
	msleep(40);

	ea8061_clear_error(ctx);

	return ea8061_power_off(ctx);
}

static int ea8061_prepare(struct drm_panel *panel)
{
	struct ea8061 *ctx = panel_to_ea8061(panel);
	int ret;

	ret = ea8061_power_on(ctx);
	if (ret < 0)
		return ret;

	ea8061_set_sequence(ctx);
	ret = ctx->error;

	if (ret < 0)
		ea8061_unprepare(panel);
	else
		set_bit(EA8061_STATE_BIT_ENABLED, &ctx->state);

	return ret;
}

static int ea8061_enable(struct drm_panel *panel)
{
	return 0;
}

static int ea8061_get_modes(struct drm_panel *panel)
{
	struct drm_connector *connector = panel->connector;
	struct ea8061 *ctx = panel_to_ea8061(panel);
	struct drm_display_mode *mode;

	mode = drm_mode_create(connector->dev);
	if (!mode) {
		DRM_ERROR("failed to create a new display mode\n");
		return 0;
	}

	drm_display_mode_from_videomode(&ctx->vm, mode);
	mode->width_mm = ctx->width_mm;
	mode->height_mm = ctx->height_mm;
	connector->display_info.width_mm = mode->width_mm;
	connector->display_info.height_mm = mode->height_mm;

	mode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;
	drm_mode_probed_add(connector, mode);

	return 1;
}

static const struct drm_panel_funcs ea8061_drm_funcs = {
	.disable = ea8061_disable,
	.unprepare = ea8061_unprepare,
	.prepare = ea8061_prepare,
	.enable = ea8061_enable,
	.get_modes = ea8061_get_modes,
};

static int ea8061_get_brightness(struct backlight_device *bd)
{
	return bd->props.brightness;
}

static int ea8061_set_brightness(struct backlight_device *bd)
{
	struct ea8061 *ctx = bl_get_data(bd);

	bd->props.power = FB_BLANK_UNBLANK;
	if (ctx->brightness != bd->props.brightness) {
		ctx->brightness = bd->props.brightness;
		if (test_bit(EA8061_STATE_BIT_ENABLED, &ctx->state))
			ea8061_brightness_set(ctx);
	}

	return ea8061_clear_error(ctx);
}

static const struct backlight_ops ea8061_backlight_ops = {
	.get_brightness = ea8061_get_brightness,
	.update_status = ea8061_set_brightness,
};

static void ea8061_backlight_register(struct ea8061 *ctx)
{
	struct backlight_properties props = {
		.type = BACKLIGHT_RAW,
		.brightness = ctx->brightness,
		.max_brightness = GAMMA_LEVEL_NUM - 1
	};
	struct device *dev = ctx->dev;
	struct backlight_device *bd;

	bd = devm_backlight_device_register(dev, "panel", dev, ctx,
					    &ea8061_backlight_ops, &props);
	if (IS_ERR(bd))
		dev_err(dev, "error registering backlight device (%ld)\n",
			PTR_ERR(bd));
}

static int ea8061_parse_dt(struct ea8061 *ctx)
{
	struct device *dev = ctx->dev;
	struct device_node *np = dev->of_node;
	int ret;

	ret = of_get_videomode(np, &ctx->vm, 0);
	if (ret < 0)
		return ret;

	of_property_read_u32(np, "power-on-delay", &ctx->power_on_delay);
	of_property_read_u32(np, "reset-delay", &ctx->reset_delay);
	of_property_read_u32(np, "init-delay", &ctx->init_delay);
	of_property_read_u32(np, "panel-width-mm", &ctx->width_mm);
	of_property_read_u32(np, "panel-height-mm", &ctx->height_mm);

	return 0;
}

static int ea8061_probe(struct mipi_dsi_device *dsi)
{
	struct device *dev = &dsi->dev;
	struct ea8061 *ctx;
	int ret;

	ctx = devm_kzalloc(dev, sizeof(struct ea8061), GFP_KERNEL);
	if (!ctx)
		return -ENOMEM;

	pr_err("ea8061 probing\n");

	mipi_dsi_set_drvdata(dsi, ctx);

	ctx->dev = dev;

	dsi->lanes = 4;
	dsi->format = MIPI_DSI_FMT_RGB888;
	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST
		| MIPI_DSI_MODE_VIDEO_HFP | MIPI_DSI_MODE_VIDEO_HBP
		| MIPI_DSI_MODE_VIDEO_HSA | MIPI_DSI_MODE_EOT_PACKET
		| MIPI_DSI_MODE_VSYNC_FLUSH | MIPI_DSI_MODE_VIDEO_AUTO_VERT;

	ret = ea8061_parse_dt(ctx);
	if (ret < 0)
		return ret;

	ctx->supplies[0].supply = "vdd3";
	ctx->supplies[1].supply = "vci";
	ret = devm_regulator_bulk_get(dev, ARRAY_SIZE(ctx->supplies),
				      ctx->supplies);
	if (ret < 0) {
		dev_err(dev, "failed to get regulators: %d\n", ret);
		return ret;
	}

	ctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
	if (IS_ERR(ctx->reset_gpio)) {
		dev_err(dev, "cannot get reset-gpios %ld\n",
			PTR_ERR(ctx->reset_gpio));
		return PTR_ERR(ctx->reset_gpio);
	}

	ctx->brightness = GAMMA_LEVEL_NUM - 1;

	drm_panel_init(&ctx->panel);
	ctx->panel.dev = dev;
	ctx->panel.funcs = &ea8061_drm_funcs;

	ret = drm_panel_add(&ctx->panel);
	if (ret < 0)
		return ret;

	ret = mipi_dsi_attach(dsi);
	if (ret < 0)
		drm_panel_remove(&ctx->panel);

	ea8061_backlight_register(ctx);

	return ret;
}

static int ea8061_remove(struct mipi_dsi_device *dsi)
{
	struct ea8061 *ctx = mipi_dsi_get_drvdata(dsi);

	mipi_dsi_detach(dsi);
	drm_panel_remove(&ctx->panel);

	return 0;
}

static const struct of_device_id ea8061_of_match[] = {
	{ .compatible = "magnachip,ea8061" },
	{ }
};
MODULE_DEVICE_TABLE(of, ea8061_of_match);

static struct mipi_dsi_driver ea8061_driver = {
	.probe = ea8061_probe,
	.remove = ea8061_remove,
	.driver = {
		.name = "panel-magnachip-ea8061",
		.of_match_table = ea8061_of_match,
	},
};
module_mipi_dsi_driver(ea8061_driver);

MODULE_AUTHOR("Simon Shields <simon@lineageos.org>");
MODULE_AUTHOR("Donghwa Lee <dh09.lee@samsung.com>");
MODULE_AUTHOR("Inki Dae <inki.dae@samsung.com>");
MODULE_AUTHOR("Joongmock Shin <jmock.shin@samsung.com>");
MODULE_AUTHOR("Eunchul Kim <chulspro.kim@samsung.com>");
MODULE_AUTHOR("Tomasz Figa <t.figa@samsung.com>");
MODULE_AUTHOR("Andrzej Hajda <a.hajda@samsung.com>");
MODULE_DESCRIPTION("MIPI-DSI based ea8061 AMOLED LCD Panel Driver");
MODULE_LICENSE("GPL v2");
